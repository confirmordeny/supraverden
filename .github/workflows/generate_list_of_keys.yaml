name: List of keys

on:
  push:
    branches:
      - main
    paths:
      - 'data/general_list.yaml'
      - 'data/united_nations.yaml'
      
  workflow_dispatch:

jobs:
  extract-keys:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Extract Keys and Generate List
        run: |
          python3 - <<'EOF'
          import os
          
          # Input files configuration
          input_files = [
              'data/general_list.yaml',
              'data/united_nations.yaml'
          ]
          output_file = 'dist/LIST_OF_KEYS.md'

          unique_keys = set()
          print("Scanning files for keys...")

          for filepath in input_files:
              if not os.path.exists(filepath):
                  print(f"Skipping missing file: {filepath}")
                  continue

              with open(filepath, 'r', encoding='utf-8') as f:
                  for line in f:
                      stripped = line.strip()
                      # Parsing logic:
                      if line.startswith(' ') and ':' in stripped and not stripped.startswith('#'):
                          key = stripped.split(':', 1)[0].strip()
                          unique_keys.add(key)

          # --- RECURSIVE GROUPING LOGIC ---

          # Helper to create nested dictionaries
          def attach_to_tree(tree, parts):
              head = parts[0]
              if head not in tree:
                  tree[head] = {'_children': {}}
              
              if len(parts) > 1:
                  attach_to_tree(tree[head]['_children'], parts[1:])
              else:
                  # Mark that this node is a valid key itself
                  tree[head]['_is_key'] = True

          key_tree = {}
          exceptions = {'Abbreviation_other', 'Assessment_against_FATF_definition', 'Legal_type', 'Entity_type', 'Immunity_url', 'Name_former', 'Name_other', 'Name_other_2', 'Org_family', 'OpenSanctions_id', 'Treaty_url', 'Wikidata_code'}

          for key in unique_keys:
              if key in exceptions:
                  # Treat exceptions as a single chunk (no splitting)
                  attach_to_tree(key_tree, [key])
              else:
                  # Split by ALL underscores to create hierarchy
                  # e.g. Name_other_en -> ['Name', 'other', 'en']
                  parts = key.split('_')
                  attach_to_tree(key_tree, parts)

          # Recursive function to generate markdown
          def generate_lines(tree, depth=0):
              lines = []
              # Sort keys alphabetically
              for node_name in sorted(tree.keys()):
                  node = tree[node_name]
                  
                  # Create the bullet point
                  indent = "  " * depth
                  lines.append(f"{indent}* {node_name}")
                  
                  # Process children if they exist
                  if '_children' in node and node['_children']:
                      lines.extend(generate_lines(node['_children'], depth + 1))
                      
              return lines

          output_lines = generate_lines(key_tree)
          formatted_output = "\n".join(output_lines)
          
          # --------------------------

          os.makedirs(os.path.dirname(output_file), exist_ok=True)
          with open(output_file, 'w', encoding='utf-8') as f:
              f.write(formatted_output)

          print(f"Successfully wrote {len(unique_keys)} keys to {output_file}")
          EOF

      - name: Commit and push if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: Update LIST_OF_KEYS.md with recursive grouping"
          file_pattern: "dist/LIST_OF_KEYS.md"
